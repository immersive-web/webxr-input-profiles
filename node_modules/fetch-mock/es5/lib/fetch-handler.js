'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var responseBuilder = require('./response-builder');
var requestUtils = require('./request-utils');
var FetchMock = {};

// see https://heycam.github.io/webidl/#aborterror for the standardised interface
// Note that this differs slightly from node-fetch

var AbortError = function (_Error) {
	(0, _inherits3.default)(AbortError, _Error);

	function AbortError() {
		(0, _classCallCheck3.default)(this, AbortError);

		var _this = (0, _possibleConstructorReturn3.default)(this, (AbortError.__proto__ || (0, _getPrototypeOf2.default)(AbortError)).apply(this, arguments));

		_this.name = 'AbortError';
		_this.message = 'The operation was aborted.';

		// Do not include this class in the stacktrace
		if (Error.captureStackTrace) {
			Error.captureStackTrace(_this, _this.constructor);
		}
		return _this;
	}

	return AbortError;
}(Error);

var resolve = function () {
	var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(_ref, url, options, request) {
		var response = _ref.response,
		    _ref$responseIsFetch = _ref.responseIsFetch,
		    responseIsFetch = _ref$responseIsFetch === undefined ? false : _ref$responseIsFetch;
		return _regenerator2.default.wrap(function _callee$(_context) {
			while (1) {
				switch (_context.prev = _context.next) {
					case 0:
						if (!true) {
							_context.next = 14;
							break;
						}

						if (!(typeof response === 'function')) {
							_context.next = 5;
							break;
						}

						// in the case of falling back to the network we need to make sure we're using
						// the original Request instance, not our normalised url + options
						response = request && responseIsFetch ? response(request) : response(url, options, request);
						_context.next = 12;
						break;

					case 5:
						if (!(typeof response.then === 'function')) {
							_context.next = 11;
							break;
						}

						_context.next = 8;
						return response;

					case 8:
						response = _context.sent;
						_context.next = 12;
						break;

					case 11:
						return _context.abrupt('return', response);

					case 12:
						_context.next = 0;
						break;

					case 14:
					case 'end':
						return _context.stop();
				}
			}
		}, _callee, undefined);
	}));

	return function resolve(_x, _x2, _x3, _x4) {
		return _ref2.apply(this, arguments);
	};
}();

FetchMock.fetchHandler = function (url, options, request) {
	var _this2 = this;

	var normalizedRequest = requestUtils.normalizeRequest(url, options, this.config.Request);

	url = normalizedRequest.url;
	options = normalizedRequest.options;
	request = normalizedRequest.request;
	var signal = normalizedRequest.signal;


	var route = this.executeRouter(url, options, request);

	// this is used to power the .flush() method
	var done = void 0;
	this._holdingPromises.push(new this.config.Promise(function (res) {
		return done = res;
	}));

	// wrapped in this promise to make sure we respect custom Promise
	// constructors defined by the user
	return new this.config.Promise(function (res, rej) {
		if (signal) {
			var abort = function abort() {
				// note that DOMException is not available in node.js; even node-fetch uses a custom error class: https://github.com/bitinn/node-fetch/blob/master/src/abort-error.js
				rej(typeof DOMException !== 'undefined' ? new DOMException('The operation was aborted.', 'AbortError') : new AbortError());
				done();
			};
			if (signal.aborted) {
				abort();
			}
			signal.addEventListener('abort', abort);
		}

		_this2.generateResponse(route, url, options, request).then(res, rej).then(done, done);
	});
};

FetchMock.fetchHandler.isMock = true;

FetchMock.executeRouter = function (url, options, request) {
	if (this.config.fallbackToNetwork === 'always') {
		return { response: this.getNativeFetch(), responseIsFetch: true };
	}

	var match = this.router(url, options, request);

	if (match) {
		return match;
	}

	if (this.config.warnOnFallback) {
		console.warn('Unmatched ' + (options && options.method || 'GET') + ' to ' + url); // eslint-disable-line
	}

	this.push({ url: url, options: options, request: request, isUnmatched: true });

	if (this.fallbackResponse) {
		return { response: this.fallbackResponse };
	}

	if (!this.config.fallbackToNetwork) {
		throw new Error('fetch-mock: No fallback response defined for ' + (options && options.method || 'GET') + ' to ' + url);
	}

	return { response: this.getNativeFetch(), responseIsFetch: true };
};

FetchMock.generateResponse = function () {
	var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(route, url, options, request) {
		var response;
		return _regenerator2.default.wrap(function _callee2$(_context2) {
			while (1) {
				switch (_context2.prev = _context2.next) {
					case 0:
						_context2.next = 2;
						return resolve(route, url, options, request);

					case 2:
						response = _context2.sent;

						if (!(response.throws && typeof response !== 'function')) {
							_context2.next = 5;
							break;
						}

						throw response.throws;

					case 5:
						if (!this.config.Response.prototype.isPrototypeOf(response)) {
							_context2.next = 7;
							break;
						}

						return _context2.abrupt('return', response);

					case 7:
						return _context2.abrupt('return', responseBuilder({
							url: url,
							responseConfig: response,
							fetchMock: this,
							route: route
						}));

					case 8:
					case 'end':
						return _context2.stop();
				}
			}
		}, _callee2, this);
	}));

	return function (_x5, _x6, _x7, _x8) {
		return _ref3.apply(this, arguments);
	};
}();

FetchMock.router = function (url, options, request) {
	var route = this.routes.find(function (route) {
		return route.matcher(url, options, request);
	});

	if (route) {
		this.push({
			url: url,
			options: options,
			request: request,
			identifier: route.identifier
		});
		return route;
	}
};

FetchMock.getNativeFetch = function () {
	var func = this.realFetch || this.isSandbox && this.config.fetch;
	if (!func) {
		throw new Error('fetch-mock: Falling back to network only available on gloabl fetch-mock, or by setting config.fetch on sandboxed fetch-mock');
	}
	return func;
};

FetchMock.push = function (_ref4) {
	var url = _ref4.url,
	    options = _ref4.options,
	    request = _ref4.request,
	    isUnmatched = _ref4.isUnmatched,
	    identifier = _ref4.identifier;

	var args = [url, options];
	args.request = request;
	args.identifier = identifier;
	args.isUnmatched = isUnmatched;
	this._calls.push(args);
};

module.exports = FetchMock;